import type { RepoAnalysis, Convention, CrossRef } from "../types.js";
import type { CodePatterns } from "../analyzers/patterns.js";

function describeArchitecture(analysis: RepoAnalysis): string[] {
  const lines: string[] = [];
  const f = analysis.framework;
  const d = analysis.detected;

  if (f?.name === "next") {
    const variant = f.variant === "app-router" ? "App Router" : f.variant === "pages-router" ? "Pages Router" : "";
    lines.push(`- **Frontend + Backend**: Next.js ${f.version} (${variant}) — full-stack React framework`);
  } else if (f?.name === "vite-react") {
    lines.push(`- **Frontend**: React SPA with Vite ${f.version}`);
  } else if (f) {
    lines.push(`- **Framework**: ${f.name} ${f.version}`);
  }

  if (d.orm) lines.push(`- **Data Layer**: ${d.orm}${d.database ? ` → ${d.database}` : ""}`);
  else if (d.database) lines.push(`- **Database**: ${d.database}`);

  if (d.auth) lines.push(`- **Authentication**: ${d.auth}`);
  if (d.apiStyle) lines.push(`- **API**: ${d.apiStyle}`);
  if (d.stateManagement) lines.push(`- **Client State**: ${d.stateManagement}`);
  if (d.i18n) lines.push(`- **i18n**: ${d.i18n}`);
  if (d.payments) lines.push(`- **Payments**: ${d.payments}`);
  if (d.realtime) lines.push(`- **Realtime**: ${d.realtime}`);
  if (d.email) lines.push(`- **Email**: ${d.email}`);
  if (d.cms) lines.push(`- **Content**: ${d.cms}`);
  if (d.jobs) lines.push(`- **Background Jobs**: ${d.jobs}`);
  if (d.fileUpload) lines.push(`- **File Upload**: ${d.fileUpload}`);

  const scale = analysis.structure.approximateFileCount;
  if (scale > 0) {
    const size = scale < 30 ? "Small" : scale < 100 ? "Medium" : scale < 300 ? "Large" : "Very large";
    lines.push(`- **Project Size**: ${size} (~${scale} source files)`);
  }

  return lines;
}

function buildDynamicInstructions(analysis: RepoAnalysis): string[] {
  const lines: string[] = [];
  const f = analysis.framework;
  const d = analysis.detected;

  lines.push("- Follow ALL rules in this document without exception.");
  lines.push("- When creating new files, respect the existing project structure and naming conventions.");
  lines.push("- When unsure about a pattern, check existing code for precedent before inventing new patterns.");
  lines.push("- Never introduce new dependencies without being explicitly asked.");
  lines.push("- Prefer small, focused changes over large refactors.");

  if (f?.name === "next" && f.variant === "app-router") {
    lines.push("- Default to Server Components. Only add 'use client' when the component needs interactivity.");
    lines.push("- Place new pages in app/ following the existing route structure.");
    lines.push("- Use Server Actions for mutations, Route Handlers for API endpoints.");
  }

  if (d.orm === "prisma") {
    lines.push("- After changing schema.prisma, always run `npx prisma migrate dev` and `npx prisma generate`.");
  } else if (d.orm === "drizzle") {
    lines.push("- After changing Drizzle schemas, run `npx drizzle-kit generate` to create migrations.");
  }

  if (d.validation === "zod") {
    lines.push("- Validate all inputs at API boundaries with Zod. Parse, don't validate.");
  }

  if (d.css === "tailwind") {
    lines.push("- Use Tailwind utility classes for styling. Use cn() for conditional classes.");
  }

  if (d.uiComponents === "shadcn") {
    lines.push("- Use shadcn/ui components from components/ui/ as building blocks.");
  }

  if (d.testing) {
    lines.push(`- Run tests with the project's ${d.testing} setup before marking work as done.`);
  }

  if (d.linter) {
    lines.push(`- Run ${d.linter} before committing. Fix all warnings.`);
  }

  if (d.i18n) {
    lines.push("- All user-facing strings must go through the i18n system. Never hardcode text.");
  }

  return lines;
}

export function generateClaudeMd(
  analysis: RepoAnalysis,
  conventions: Convention[],
  interdictions: string[],
  crossRefs: CrossRef[],
  choices: Record<string, string>,
  patterns?: CodePatterns
): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${analysis.projectName} — Project Rules`);
  lines.push("");
  lines.push("> Auto-generated by [LeadCode](https://github.com/Julxoo/LeadCode). This file is the source of truth for Claude Code.");
  lines.push("> Modify as needed, then commit to version control.");
  lines.push("");

  // Architecture overview
  const archLines = describeArchitecture(analysis);
  if (archLines.length > 0) {
    lines.push("## Architecture Overview");
    lines.push("");
    lines.push(...archLines);
    lines.push("");
  }

  // Stack details
  lines.push("## Stack");
  lines.push("");
  if (analysis.framework) {
    const variant = analysis.framework.variant
      ? ` (${analysis.framework.variant})`
      : "";
    lines.push(
      `- **Framework**: ${analysis.framework.name} ${analysis.framework.version}${variant}`
    );
  }
  const d = analysis.detected;
  if (d.orm) lines.push(`- **ORM**: ${d.orm}`);
  if (d.database) lines.push(`- **Database**: ${d.database}`);
  if (d.auth) lines.push(`- **Auth**: ${d.auth}`);
  if (d.validation) lines.push(`- **Validation**: ${d.validation}`);
  if (d.css) lines.push(`- **CSS**: ${d.css}`);
  if (d.uiComponents) lines.push(`- **UI Components**: ${d.uiComponents}`);
  if (d.testing) lines.push(`- **Testing**: ${d.testing}`);
  if (d.stateManagement) lines.push(`- **State Management**: ${d.stateManagement}`);
  if (d.apiStyle) lines.push(`- **API Style**: ${d.apiStyle}`);
  if (d.i18n) lines.push(`- **i18n**: ${d.i18n}`);
  if (d.payments) lines.push(`- **Payments**: ${d.payments}`);
  if (d.email) lines.push(`- **Email**: ${d.email}`);
  if (d.realtime) lines.push(`- **Realtime**: ${d.realtime}`);
  if (d.cms) lines.push(`- **CMS/Content**: ${d.cms}`);
  if (d.fileUpload) lines.push(`- **File Upload**: ${d.fileUpload}`);
  if (d.jobs) lines.push(`- **Jobs/Queue**: ${d.jobs}`);
  if (d.monorepo) lines.push(`- **Monorepo**: ${d.monorepo}`);
  if (d.deployment) lines.push(`- **Deployment**: ${d.deployment}`);
  if (d.linter) lines.push(`- **Linter**: ${d.linter}`);
  if (d.formatter) lines.push(`- **Formatter**: ${d.formatter}`);
  if (d.runtime && d.runtime !== "node") lines.push(`- **Runtime**: ${d.runtime}`);
  lines.push("");

  // Project structure
  lines.push("## Project Structure");
  lines.push("");
  const s = analysis.structure;
  if (s.hasSrcDir) lines.push("- Source code in `src/`");
  if (s.hasAppDir) lines.push("- App Router: `app/`");
  if (s.hasPagesDir) lines.push("- Pages Router: `pages/`");
  if (s.hasApiRoutes) lines.push("- API routes present");
  if (s.hasMiddleware) lines.push("- Middleware configured");
  if (s.hasComponentsDir) lines.push("- Components: `components/`");
  if (s.hasLibDir) lines.push("- Shared utilities: `lib/`");
  if (s.hasServicesDir) lines.push("- Services: `services/`");
  if (s.hasHooksDir) lines.push("- Custom hooks: `hooks/`");
  if (s.hasStoreDir) lines.push("- State stores: `store/`");
  if (s.hasSchemasDir) lines.push("- Validation schemas: `schemas/`");
  if (s.hasTypesDir) lines.push("- Type definitions: `types/`");
  if (s.hasConfigDir) lines.push("- Configuration: `config/`");
  if (s.hasProvidersDir) lines.push("- React providers: `providers/`");
  if (s.hasPrismaSchema) lines.push("- Prisma schema: `prisma/schema.prisma`");
  lines.push("");

  // Scripts
  const scripts = Object.entries(analysis.scripts);
  if (scripts.length > 0) {
    lines.push("## Available Scripts");
    lines.push("");
    for (const [name, cmd] of scripts) {
      lines.push(`- \`npm run ${name}\` → \`${cmd}\``);
    }
    lines.push("");
  }

  // File naming conventions
  lines.push("## File & Naming Conventions");
  lines.push("");
  lines.push("- **Files**: kebab-case (e.g., `user-profile.ts`, `auth-utils.ts`)");
  lines.push("- **React components**: PascalCase filename matching component name (e.g., `UserProfile.tsx` exports `UserProfile`)");
  lines.push("- **Hooks**: camelCase prefixed with `use` (e.g., `useAuth.ts`)");
  lines.push("- **Constants/config**: SCREAMING_SNAKE_CASE for values, kebab-case for files");
  if (s.hasSrcDir) {
    lines.push("- **New files**: Place in `src/` following the existing directory structure");
  }
  lines.push("");

  // Import ordering
  lines.push("## Import Ordering");
  lines.push("");
  lines.push("```");
  lines.push("1. Node.js builtins (node:fs, node:path)");
  lines.push("2. External packages (react, next, etc.)");
  lines.push("3. Internal aliases (@/ or ~/)");
  lines.push("4. Relative imports (../ and ./)");
  lines.push("5. Type imports (import type { ... })");
  lines.push("```");
  lines.push("");

  // Conventions
  if (conventions.length > 0) {
    lines.push("## Conventions (MUST follow)");
    lines.push("");
    for (const conv of conventions) {
      lines.push(`### ${conv.description}`);
      lines.push(`<!-- id:${conv.id} -->`);
      lines.push(conv.rule);
      lines.push("");
    }
  }

  // Cross-stack rules
  if (crossRefs.length > 0) {
    lines.push("## Cross-Stack Rules (CRITICAL)");
    lines.push("");
    for (const cr of crossRefs) {
      lines.push(`### ${cr.techs.join(" + ")}`);
      lines.push("");
      for (const conv of cr.conventions) {
        lines.push(`- **${conv.description}**: ${conv.rule}`);
      }
      if (cr.interdictions.length > 0) {
        lines.push("");
        for (const inter of cr.interdictions) {
          lines.push(`- ${inter}`);
        }
      }
      lines.push("");
    }
  }

  // Interdictions
  if (interdictions.length > 0) {
    lines.push("## Interdictions (NEVER do)");
    lines.push("");
    for (const inter of interdictions) {
      lines.push(`- ${inter}`);
    }
    lines.push("");
  }

  // User choices
  const choiceEntries = Object.entries(choices);
  if (choiceEntries.length > 0) {
    lines.push("## Project Decisions");
    lines.push("");
    for (const [topic, choice] of choiceEntries) {
      lines.push(`- **${topic}**: ${choice}`);
    }
    lines.push("");
  }

  // Existing code patterns
  if (patterns) {
    const patternLines: string[] = [];
    if (patterns.totalComponents > 0) {
      patternLines.push(`- **Client/Server ratio**: ${patterns.useClientCount} client components out of ${patterns.totalComponents} total (${Math.round(patterns.clientRatio * 100)}% client)`);
    }
    if (patterns.useServerCount > 0) {
      patternLines.push(`- **Server Actions**: ${patterns.useServerCount} files with 'use server'`);
    }
    if (patterns.usesPathAlias) {
      patternLines.push("- **Path aliases**: Project uses @/ or ~/ imports — keep using them");
    }
    if (patterns.hasBarrelFiles) {
      patternLines.push("- **Barrel files**: Project uses index.ts re-exports — follow this pattern");
    }
    if (patterns.largeFiles.length > 0) {
      patternLines.push(`- **Large files** (>300 lines): ${patterns.largeFiles.length} file(s) — consider splitting`);
    }
    if (patterns.consoleLogCount > 0) {
      patternLines.push(`- **Console.log**: ${patterns.consoleLogCount} occurrences found — clean up before production`);
    }
    if (patternLines.length > 0) {
      lines.push("## Existing Code Patterns");
      lines.push("");
      lines.push(...patternLines);
      lines.push("");
    }
  }

  // Dynamic Claude Code instructions
  lines.push("## Claude Code Instructions");
  lines.push("");
  const instructions = buildDynamicInstructions(analysis);
  for (const instr of instructions) {
    lines.push(instr);
  }
  lines.push("");

  return lines.join("\n");
}
