import type { RepoAnalysis, RecognizedTech } from "../types.js";
import type { CodePatterns } from "../analyzers/patterns.js";
import type { FetchedDocs } from "../types.js";

/** Group recognized techs by category */
function groupByCategory(recognized: Record<string, RecognizedTech>): Record<string, RecognizedTech[]> {
  const groups: Record<string, RecognizedTech[]> = {};
  for (const tech of Object.values(recognized)) {
    if (!groups[tech.category]) groups[tech.category] = [];
    groups[tech.category].push(tech);
  }
  return groups;
}

/** Category display labels */
const CATEGORY_LABELS: Record<string, string> = {
  orm: "ORM",
  "database-driver": "Database Driver",
  "query-builder": "Query Builder",
  auth: "Authentication",
  validation: "Validation",
  css: "Styling",
  testing: "Testing",
  state: "State Management",
  "data-fetching": "Data Fetching",
  forms: "Forms",
  api: "API",
  bundler: "Bundler",
  linter: "Linter",
  formatter: "Formatter",
  i18n: "i18n",
  monorepo: "Monorepo",
  database: "Database",
  email: "Email",
  "file-upload": "File Upload",
  payments: "Payments",
  realtime: "Realtime",
  cms: "CMS",
  jobs: "Background Jobs",
  "ui-components": "UI Components",
  observability: "Observability",
  logging: "Logging",
  deployment: "Deployment",
};

function categoryLabel(cat: string): string {
  return CATEGORY_LABELS[cat] ?? cat.replace(/-/g, " ").replace(/(^|\s)\w/g, c => c.toUpperCase());
}

function describeArchitecture(analysis: RepoAnalysis): string[] {
  const lines: string[] = [];
  const f = analysis.framework;
  const groups = groupByCategory(analysis.detected.recognized);

  // Framework
  if (f) {
    const variant = f.variant && f.variant !== "unknown" ? ` (${f.variant === "app-router" ? "App Router" : f.variant === "pages-router" ? "Pages Router" : f.variant})` : "";
    lines.push(`- **Framework**: ${techDisplayName(f.name)} ${f.version}${variant}`);
  }

  // Group display: skip categories already covered by framework or patterns
  const skipCategories = new Set(["bundler", "linter", "formatter"]);
  for (const [category, techs] of Object.entries(groups)) {
    if (skipCategories.has(category)) continue;
    const techList = techs.map(t => t.version ? `${techDisplayName(t.name)} ${t.version}` : techDisplayName(t.name)).join(", ");
    lines.push(`- **${categoryLabel(category)}**: ${techList}`);
  }

  // Tooling (bundler, linter, formatter on one line if present)
  const tooling: string[] = [];
  for (const cat of ["bundler", "linter", "formatter"]) {
    if (groups[cat]) {
      tooling.push(...groups[cat].map(t => t.name));
    }
  }
  if (tooling.length > 0) {
    lines.push(`- **Tooling**: ${tooling.join(", ")}`);
  }

  // Runtime & scale
  const s = analysis.structure;
  lines.push(`- **Runtime**: ${s.detectedRuntime}`);
  if (analysis.packageManager) lines.push(`- **Package Manager**: ${analysis.packageManager}`);
  if (analysis.workspaces) lines.push(`- **Workspaces**: ${analysis.workspaces.join(", ")}`);

  if (s.approximateFileCount > 0) {
    const size = s.approximateFileCount < 30 ? "small"
      : s.approximateFileCount < 100 ? "medium"
      : s.approximateFileCount < 300 ? "large"
      : "very large";
    lines.push(`- **Project size**: ${size} (~${s.approximateFileCount} source files)`);
  }

  return lines;
}

/** Format a tech name for section headers */
function techDisplayName(tech: string): string {
  const names: Record<string, string> = {
    next: "Next.js", react: "React", "vite-react": "Vite + React",
    nuxt: "Nuxt", remix: "Remix", astro: "Astro", sveltekit: "SvelteKit",
    express: "Express", fastify: "Fastify", hono: "Hono",
    prisma: "Prisma", drizzle: "Drizzle", typeorm: "TypeORM", mongoose: "Mongoose", kysely: "Kysely",
    "next-auth": "NextAuth.js", clerk: "Clerk", "better-auth": "Better Auth", auth0: "Auth0",
    zod: "Zod", valibot: "Valibot",
    tailwind: "Tailwind CSS", shadcn: "shadcn/ui", chakra: "Chakra UI", mui: "Material UI", mantine: "Mantine",
    vitest: "Vitest", jest: "Jest", playwright: "Playwright", cypress: "Cypress",
    zustand: "Zustand", redux: "Redux Toolkit", jotai: "Jotai",
    "react-query": "TanStack Query", swr: "SWR",
    "react-hook-form": "React Hook Form",
    trpc: "tRPC", stripe: "Stripe", resend: "Resend",
    "next-intl": "next-intl", i18next: "i18next",
    "socket.io": "Socket.IO", inngest: "Inngest",
    sanity: "Sanity", contentful: "Contentful",
    sentry: "Sentry", winston: "Winston", pino: "Pino",
  };
  return names[tech] ?? tech.replace(/(^|\s|-)\w/g, c => c.toUpperCase()).replace(/-/g, " ");
}

export function generateClaudeMd(
  analysis: RepoAnalysis,
  docs: FetchedDocs,
  choices: Record<string, string>,
  patterns?: CodePatterns,
): string {
  const lines: string[] = [];
  const s = analysis.structure;

  // Header
  lines.push(`# CLAUDE.md — ${analysis.projectName}`);
  lines.push("");
  lines.push("> Generated by LeadCode. Edit freely — this is YOUR project's rules.");
  lines.push("> Re-run update-project to refresh after major dependency changes.");
  lines.push("");

  // Workflow
  lines.push("## Workflow");
  lines.push("");
  lines.push("When the user asks you to implement, fix, or modify something:");
  lines.push("");
  lines.push("1. **Research first** — Before writing any code, investigate the problem thoroughly: search the codebase, read relevant files, and use web search if needed. Present your findings and analysis to the user and ask for confirmation before proceeding.");
  lines.push("2. **Plan before coding** — Once the user confirms the direction, switch to plan mode to design the implementation. Only start coding after the plan is approved.");
  lines.push("");
  lines.push("Skip this workflow only for trivial changes (typos, single-line fixes, simple renames).");
  lines.push("");

  // Architecture overview
  lines.push("## Architecture Overview");
  lines.push("");
  lines.push(...describeArchitecture(analysis));
  lines.push("");

  // Structure
  const allDirs = s.hasSrcDir
    ? [`src/ → ${s.srcDirs.join(", ") || "(empty)"}`]
    : [];
  if (s.topLevelDirs.length > 0) {
    allDirs.push(`Root dirs: ${s.topLevelDirs.join(", ")}`);
  }
  if (allDirs.length > 0) {
    lines.push("**Structure:**");
    for (const d of allDirs) lines.push(`- ${d}`);
    // Infra flags
    if (s.hasPrismaSchema) lines.push("- Prisma schema at `prisma/schema.prisma`");
    if (s.hasDockerfile) lines.push("- Docker configuration present");
    if (s.hasEnvValidation) lines.push("- Environment validation configured");
    if (s.hasMiddleware) lines.push("- Middleware configured");
    if (s.hasAppDir) lines.push("- Next.js App Router (`app/`)");
    if (s.hasPagesDir) lines.push("- Pages directory (`pages/`)");
    if (s.hasApiRoutes) lines.push("- API routes present");
    lines.push("");
  }

  // Scripts — show all
  const scripts = Object.entries(analysis.scripts);
  if (scripts.length > 0) {
    lines.push("**Scripts:**");
    const shown = scripts.length <= 15 ? scripts : scripts.slice(0, 15);
    for (const [name, cmd] of shown) {
      lines.push(`- \`npm run ${name}\` → \`${cmd}\``);
    }
    if (scripts.length > 15) {
      lines.push(`- ... and ${scripts.length - 15} more`);
    }
    lines.push("");
  }

  // Codebase patterns
  if (patterns) {
    const patternLines: string[] = [];
    if (patterns.totalComponents > 0) {
      patternLines.push(`Client components: ${patterns.useClientCount}/${patterns.totalComponents} (${Math.round(patterns.clientRatio * 100)}% 'use client')`);
    }
    if (patterns.useServerCount > 0) {
      patternLines.push(`Server Actions: ${patterns.useServerCount} files with 'use server'`);
    }
    if (patterns.usesPathAlias) patternLines.push("Uses @/ or ~/ path aliases");
    if (patterns.hasBarrelFiles) patternLines.push("Uses barrel files (index.ts re-exports)");
    if (patterns.largeFiles.length > 0) {
      patternLines.push(`${patterns.largeFiles.length} large files (>300 lines)`);
    }
    if (patterns.consoleLogCount > 0) {
      patternLines.push(`${patterns.consoleLogCount} console.log calls found`);
    }
    if (patternLines.length > 0) {
      lines.push("**Codebase patterns:**");
      for (const pl of patternLines) lines.push(`- ${pl}`);
      lines.push("");
    }
  }

  // Per-tech documentation
  const techEntries = Object.entries(docs.techDocs);
  if (techEntries.length > 0) {
    for (const [tech, docContent] of techEntries) {
      if (!docContent.trim()) continue;
      lines.push(`## ${techDisplayName(tech)}`);
      lines.push("");
      lines.push(docContent.trim());
      lines.push("");
    }
  }

  // Cross-stack conventions
  const crossEntries = Object.entries(docs.crossDocs);
  if (crossEntries.length > 0) {
    const crossContent = crossEntries
      .map(([, content]) => content.trim())
      .filter(Boolean)
      .join("\n");
    if (crossContent) {
      lines.push("## Cross-Stack Conventions");
      lines.push("");
      lines.push(crossContent);
      lines.push("");
    }
  }

  // Conventions (auto-detected)
  if (patterns) {
    const convLines: string[] = [];
    if (patterns.fileNamingStyle !== "mixed") {
      convLines.push(`- File naming: ${patterns.fileNamingStyle}`);
    }
    if (patterns.hasReactFiles) {
      convLines.push("- React components: PascalCase filename = component name");
      convLines.push("- Hooks: camelCase prefixed with `use`");
    }
    if (patterns.usesPathAlias) {
      convLines.push("- Imports use @/ or ~/ path aliases");
    }
    if (patterns.hasBarrelFiles) {
      convLines.push("- Barrel files: index.ts re-exports — follow this pattern");
    }
    if (patterns.importOrder) {
      convLines.push(`- Import order: ${patterns.importOrder.join(" → ")}`);
    }
    if (patterns.indentation) {
      const desc = patterns.indentation.style === "tabs" ? "Tabs" : `${patterns.indentation.size} spaces`;
      convLines.push(`- Indentation: ${desc}`);
    }
    if (patterns.quoteStyle && patterns.quoteStyle !== "mixed") {
      convLines.push(`- Quotes: ${patterns.quoteStyle}`);
    }
    if (s.hasSrcDir) {
      convLines.push("- New files go in `src/`");
    }
    if (convLines.length > 0) {
      lines.push("## Conventions");
      lines.push("");
      lines.push(...convLines);
      lines.push("");
    }
  }

  // User choices
  const choiceEntries = Object.entries(choices);
  if (choiceEntries.length > 0) {
    lines.push("## Project Decisions");
    lines.push("");
    for (const [topic, choice] of choiceEntries) {
      lines.push(`- **${topic}**: ${choice}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}
