import type { Messages } from "./types.js";

export const fr: Messages = {
  templates: {
    header: {
      title: "{name} — Règles du projet",
      meta1: "Généré automatiquement par [LeadCode](https://github.com/Julxoo/LeadCode). Ce fichier est la source de vérité pour Claude Code.",
      meta2: "Modifiez selon vos besoins, puis committez dans le contrôle de version.",
    },
    sections: {
      architectureOverview: "Vue d'ensemble de l'architecture",
      stack: "Stack technique",
      projectStructure: "Structure du projet",
      availableScripts: "Scripts disponibles",
      fileNaming: "Conventions de nommage",
      importOrdering: "Ordre des imports",
      conventions: "Conventions (À SUIVRE impérativement)",
      crossStackRules: "Règles cross-stack (CRITIQUE)",
      interdictions: "Interdictions (JAMAIS faire)",
      projectDecisions: "Décisions du projet",
      existingPatterns: "Patterns existants",
      claudeInstructions: "Instructions pour Claude Code",
    },
    architecture: {
      frontendBackend: "Frontend + Backend",
      fullStackReact: "framework React full-stack",
      frontend: "Frontend",
      reactSpaVite: "SPA React avec Vite",
      framework: "Framework",
      dataLayer: "Couche de données",
      database: "Base de données",
      authentication: "Authentification",
      api: "API",
      clientState: "État client",
      i18n: "i18n",
      payments: "Paiements",
      realtime: "Temps réel",
      email: "Email",
      content: "Contenu",
      backgroundJobs: "Tâches de fond",
      fileUpload: "Upload de fichiers",
      projectSize: "Taille du projet",
      sizeSmall: "Petit",
      sizeMedium: "Moyen",
      sizeLarge: "Grand",
      sizeVeryLarge: "Très grand",
      sourceFiles: "fichiers source",
    },
    stackLabels: {
      framework: "Framework",
      orm: "ORM",
      database: "Base de données",
      auth: "Auth",
      validation: "Validation",
      css: "CSS",
      uiComponents: "Composants UI",
      testing: "Tests",
      stateManagement: "Gestion d'état",
      apiStyle: "Style d'API",
      i18n: "i18n",
      payments: "Paiements",
      email: "Email",
      realtime: "Temps réel",
      cms: "CMS/Contenu",
      fileUpload: "Upload de fichiers",
      jobs: "Jobs/File d'attente",
      monorepo: "Monorepo",
      deployment: "Déploiement",
      linter: "Linter",
      formatter: "Formatter",
      runtime: "Runtime",
    },
    structure: {
      srcDir: "Code source dans `src/`",
      appRouter: "App Router : `app/`",
      pagesRouter: "Pages Router : `pages/`",
      apiRoutes: "Routes API présentes",
      middleware: "Middleware configuré",
      components: "Composants : `components/`",
      sharedUtils: "Utilitaires partagés : `lib/`",
      services: "Services : `services/`",
      customHooks: "Hooks personnalisés : `hooks/`",
      stateStores: "Stores d'état : `store/`",
      validationSchemas: "Schémas de validation : `schemas/`",
      typeDefinitions: "Définitions de types : `types/`",
      configuration: "Configuration : `config/`",
      reactProviders: "Providers React : `providers/`",
      prismaSchema: "Schéma Prisma : `prisma/schema.prisma`",
    },
    naming: {
      files: "**Fichiers** : kebab-case (ex. `user-profile.ts`, `auth-utils.ts`)",
      reactComponents: "**Composants React** : PascalCase, le nom du fichier correspond au composant (ex. `UserProfile.tsx` exporte `UserProfile`)",
      hooks: "**Hooks** : camelCase préfixé par `use` (ex. `useAuth.ts`)",
      constants: "**Constantes/config** : SCREAMING_SNAKE_CASE pour les valeurs, kebab-case pour les fichiers",
      newFilesSrc: "**Nouveaux fichiers** : Placer dans `src/` en respectant la structure existante",
    },
    importOrder: [
      "1. Builtins Node.js (node:fs, node:path)",
      "2. Packages externes (react, next, etc.)",
      "3. Alias internes (@/ ou ~/)",
      "4. Imports relatifs (../ et ./)",
      "5. Imports de types (import type { ... })",
    ],
    instructions: {
      followAll: "Suivre TOUTES les règles de ce document sans exception.",
      respectStructure: "Lors de la création de nouveaux fichiers, respecter la structure et les conventions de nommage existantes.",
      checkPrecedent: "En cas de doute sur un pattern, vérifier le code existant avant d'en inventer un nouveau.",
      neverNewDeps: "Ne jamais ajouter de nouvelles dépendances sans y être explicitement invité.",
      smallChanges: "Préférer des changements petits et ciblés plutôt que de gros refactors.",
      serverComponents: "Par défaut, utiliser les Server Components. N'ajouter 'use client' que si le composant a besoin d'interactivité.",
      appRouterPages: "Placer les nouvelles pages dans app/ en suivant la structure de routes existante.",
      serverActions: "Utiliser les Server Actions pour les mutations, les Route Handlers pour les endpoints API.",
      prismaAfterChange: "Après modification de schema.prisma, toujours exécuter `npx prisma migrate dev` et `npx prisma generate`.",
      drizzleAfterChange: "Après modification des schémas Drizzle, exécuter `npx drizzle-kit generate` pour créer les migrations.",
      zodValidate: "Valider toutes les entrées aux frontières API avec Zod. Parser, pas valider.",
      tailwindClasses: "Utiliser les classes utilitaires Tailwind pour le style. Utiliser cn() pour les classes conditionnelles.",
      shadcnComponents: "Utiliser les composants shadcn/ui de components/ui/ comme briques de base.",
      runTests: "Lancer les tests avec {testing} avant de considérer le travail terminé.",
      runLinter: "Lancer {linter} avant de committer. Corriger tous les warnings.",
      i18nStrings: "Toutes les chaînes visibles par l'utilisateur doivent passer par le système i18n. Ne jamais coder en dur.",
    },
    patterns: {
      clientServerRatio: "**Ratio Client/Serveur** : {clientCount} composants client sur {totalCount} au total ({clientPercent}% client)",
      serverActions: "**Server Actions** : {count} fichiers avec 'use server'",
      pathAliases: "**Alias de chemins** : Le projet utilise les imports @/ ou ~/ — continuer à les utiliser",
      barrelFiles: "**Fichiers barrel** : Le projet utilise les ré-exports via index.ts — suivre ce pattern",
      largeFiles: "**Fichiers volumineux** (>300 lignes) : {count} fichier(s) — envisager de découper",
      consoleLogs: "**Console.log** : {count} occurrences trouvées — nettoyer avant la production",
    },
  },

  suggestions: {
    testing: {
      topic: "Stratégie de tests",
      simple: {
        description: "Ajouter Vitest pour les tests unitaires uniquement",
        pros: ["Mise en place rapide", "Léger", "Excellente DX"],
        cons: ["Pas de couverture E2E"],
        claudeImpact: "Claude générera des tests unitaires à côté des nouvelles fonctions quand on le demande.",
      },
      clean: {
        description: "Vitest + Testing Library pour les tests de composants",
        pros: ["Couverture unitaire + composants", "Teste le comportement utilisateur"],
        cons: ["Plus de configuration", "Tests de composants plus lents"],
        claudeImpact: "Claude générera des tests unitaires et de composants avec les bons patterns render/assert.",
      },
      scalable: {
        description: "Vitest + Testing Library + Playwright pour le E2E",
        pros: ["Pyramide de tests complète", "Détecte les bugs d'intégration"],
        cons: ["Configuration conséquente", "CI plus lente"],
        claudeImpact: "Claude générera des tests à tous les niveaux en respectant la pyramide de tests.",
      },
    },
    inputValidation: {
      topic: "Validation des entrées",
      simple: {
        description: "Ajouter Zod pour la validation manuelle dans les routes API",
        pros: ["Minimal", "Natif TypeScript"],
        cons: ["Il faut penser à valider chaque route"],
        claudeImpact: "Claude ajoutera z.object().parse() dans les routes API quand on le rappelle.",
      },
      clean: {
        description: "Zod avec un dossier de schémas partagés et un middleware",
        pros: ["Schémas DRY", "Validation cohérente"],
        cons: ["Plus de structure au départ"],
        claudeImpact: "Claude importera les schémas partagés et validera automatiquement dans chaque route.",
      },
    },
    errorHandling: {
      topic: "Gestion des erreurs",
      simple: {
        description: "Ajouter error.tsx dans chaque segment de route",
        pros: ["Rapide", "Suit les conventions Next.js"],
        cons: ["Pas de logging structuré des erreurs"],
        claudeImpact: "Claude créera des fichiers error.tsx et gérera les erreurs proprement.",
      },
      clean: {
        description: "Error boundaries + utilitaires d'erreur centralisés + logging structuré",
        pros: ["Format d'erreur cohérent", "Débugable"],
        cons: ["Plus de mise en place"],
        claudeImpact: "Claude utilisera les utilitaires d'erreur de manière cohérente et produira des réponses d'erreur débugables.",
      },
    },
    schemaOrg: {
      topic: "Organisation des schémas",
      simple: {
        description: "Co-localiser les schémas à côté de leurs routes API",
        pros: ["Facile à trouver", "Pas d'indirection"],
        cons: ["Les schémas se dupliquent entre les routes"],
        claudeImpact: "Claude dupliquera les schémas quand les mêmes données sont utilisées dans plusieurs routes.",
      },
      clean: {
        description: "Dossier partagé /lib/schemas/",
        pros: ["Source unique de vérité", "DRY"],
        cons: ["Un dossier de plus à gérer"],
        claudeImpact: "Claude trouvera et réutilisera les schémas de manière cohérente entre les routes et les formulaires.",
      },
    },
    componentStructure: {
      topic: "Organisation des composants",
      simple: {
        description: "Dossier /components à plat",
        pros: ["Simple", "Fonctionne pour les petits projets"],
        cons: ["Devient le bazar à l'échelle"],
        claudeImpact: "Claude placera tous les composants dans un seul dossier.",
      },
      clean: {
        description: "Organisation par feature : /components/ui/ + /components/[feature]/",
        pros: ["Passe à l'échelle", "Propriété claire"],
        cons: ["Plus de dossiers"],
        claudeImpact: "Claude organisera les composants par feature et réutilisera les primitives UI.",
      },
    },
    authMiddleware: {
      topic: "Protection des routes",
      simple: {
        description: "Vérifier l'auth dans chaque Server Component/route handler",
        pros: ["Explicite", "Facile à comprendre"],
        cons: ["Facile d'oublier sur les nouvelles routes"],
        claudeImpact: "Claude risque d'oublier les checks d'auth sur les nouvelles routes si on ne le rappelle pas.",
      },
      clean: {
        description: "middleware.ts avec route matcher + vérifications par route en backup",
        pros: ["Centralisé", "Défense en profondeur"],
        cons: ["Le middleware peut être difficile à débuguer"],
        claudeImpact: "Claude ajoutera les routes au matcher protégé et conservera les vérifications côté serveur.",
      },
    },
    loadingStates: {
      topic: "États de chargement",
      simple: {
        description: "Ajouter un seul loading.tsx à la racine de app/",
        pros: ["Rapide", "Couvre toutes les routes"],
        cons: ["Même UI de chargement partout"],
        claudeImpact: "Claude verra le pattern et créera des loading.tsx pour les nouveaux segments de route.",
      },
      clean: {
        description: "loading.tsx par segment avec des skeleton UIs adaptées à chaque page",
        pros: ["Meilleure UX", "Skeletons adaptés au layout"],
        cons: ["Plus de fichiers à maintenir"],
        claudeImpact: "Claude créera des skeleton UIs correspondant à chaque nouveau segment de route.",
      },
    },
    metadata: {
      topic: "SEO & Métadonnées",
      simple: {
        description: "Export statique des métadonnées dans chaque page.tsx",
        pros: ["Simple", "Couvre le SEO de base"],
        cons: ["Pas de métadonnées dynamiques pour les routes dynamiques"],
        claudeImpact: "Claude ajoutera export const metadata aux nouvelles pages.",
      },
      clean: {
        description: "generateMetadata pour les pages dynamiques + métadonnées statiques pour le reste",
        pros: ["Titre/description dynamique par route", "Contrôle SEO complet"],
        cons: ["Plus de boilerplate par page"],
        claudeImpact: "Claude générera les fonctions generateMetadata avec les données dynamiques.",
      },
    },
    prismaClient: {
      topic: "Singleton Prisma Client",
      simple: {
        description: "Pattern globalThis dans lib/prisma.ts",
        pros: ["Approche standard", "Évite les fuites de hot-reload"],
        cons: ["Nécessite de la discipline pour toujours importer depuis ce fichier"],
        claudeImpact: "Claude importera depuis lib/prisma.ts de manière cohérente.",
      },
    },
    authSession: {
      topic: "Utilitaire d'authentification",
      simple: {
        description: "Créer lib/auth.ts avec une fonction getCurrentUser()",
        pros: ["Centralisé", "Facile à utiliser"],
        cons: ["Il faut penser à l'utiliser"],
        claudeImpact: "Claude appellera getCurrentUser() dans les Server Components et Route Handlers.",
      },
      clean: {
        description: "lib/auth.ts avec getCurrentUser() + requireAuth() qui throw si pas de session",
        pros: ["Sécurisé par défaut", "Intention claire"],
        cons: ["Un peu plus de code"],
        claudeImpact: "Claude utilisera requireAuth() en haut des routes protégées automatiquement.",
      },
    },
    envValidation: {
      topic: "Validation des variables d'environnement",
      simple: {
        description: "Validation manuelle avec Zod dans env.ts",
        pros: ["Pas de dépendance supplémentaire", "Contrôle total"],
        cons: ["Maintenance manuelle"],
        claudeImpact: "Claude importera les variables d'env depuis env.ts et n'utilisera jamais process.env directement.",
      },
      clean: {
        description: "Utiliser @t3-oss/env-nextjs pour un env typé avec séparation client/serveur",
        pros: ["Typé", "Séparation client/serveur forcée"],
        cons: ["Dépendance supplémentaire"],
        claudeImpact: "Claude importera depuis env.mjs et respectera les frontières client/serveur.",
      },
    },
    typesDir: {
      topic: "Organisation des types partagés",
      simple: {
        description: "Créer un dossier types/ avec des fichiers de types par domaine",
        pros: ["Emplacement clair pour les types partagés"],
        cons: ["Un dossier de plus"],
        claudeImpact: "Claude placera les types partagés dans types/ et importera depuis ce dossier.",
      },
    },
    storeOrg: {
      topic: "Organisation des stores",
      simple: {
        description: "Créer un dossier store/ avec un fichier par store",
        pros: ["Simple", "Facile à trouver"],
        cons: ["Structure à plat"],
        claudeImpact: "Claude créera les stores dans store/ avec un nommage clair.",
      },
    },
    drizzleSchema: {
      topic: "Organisation des schémas Drizzle",
      simple: {
        description: "Tous les schémas dans db/schema.ts",
        pros: ["Simple pour les petits projets"],
        cons: ["Grossit vite"],
        claudeImpact: "Claude ajoutera les nouvelles tables dans le fichier de schéma unique.",
      },
      clean: {
        description: "Dossier db/schema/ avec un fichier par entité + barrel index.ts",
        pros: ["Passe à l'échelle", "Facile à trouver"],
        cons: ["Plus de fichiers"],
        claudeImpact: "Claude créera de nouveaux fichiers de schéma par entité et les exportera depuis index.ts.",
      },
    },
    genericFix: "Corriger : {message}",
    genericPros: ["Corrige le problème"],
    genericCons: ["Peut nécessiter des ajustements"],
    genericClaudeImpact: "Claude suivra la convention une fois documentée dans le CLAUDE.md.",
  },

  validation: {
    noClaudeMd: "Aucun CLAUDE.md trouvé à {path}. Utilisez generate-claude-md d'abord.",
    frameworkVersionOutdated: "La version {version} du framework n'est pas dans le CLAUDE.md. La version a peut-être été mise à jour.",
    techMissing: "{label} : {value} est dans le projet mais pas mentionné dans le CLAUDE.md.",
    conventionMissing: "La convention « {description} » est applicable mais absente du CLAUDE.md.",
    crossStackMissing: "La règle cross-stack pour {combo} est applicable mais absente du CLAUDE.md.",
    gapStillExists: "Un gap de haute sévérité persiste : {message}",
    inSync: "Le CLAUDE.md est synchronisé avec le projet.",
    driftsFound: "{count} décalage(s) trouvé(s). Envisagez de lancer generate-claude-md pour mettre à jour.",
  },

  tools: {
    generateSuccess: "CLAUDE.md généré avec succès",
    updateSuccess: "CLAUDE.md mis à jour avec succès",
    dirNotFound: "Dossier du projet introuvable : {path}",
  },

  prompts: {
    setupTitle: "Workflow complet LeadCode : analyser le repo → détecter les manques → proposer des conventions → générer le CLAUDE.md",
    setupSteps: [
      "1. Lance analyze-repo pour scanner le projet et obtenir une analyse technique complète.",
      "2. Lance detect-gaps pour identifier les manques structurels.",
      "3. Lance suggest-conventions pour proposer des améliorations.",
      "4. Présente un résumé clair : ce qui est détecté, ce qui manque, et les options disponibles.",
      "5. Demande-moi mes préférences pour chaque point (simple / clean / scalable).",
      "6. Une fois mes choix faits, lance generate-claude-md pour créer le CLAUDE.md.",
      "",
      "Explique chaque étape simplement et clairement.",
    ],
    validateTitle: "Vérifier si le CLAUDE.md est encore synchronisé avec le projet",
    validateSteps: [
      "1. Lance validate-claude-md pour vérifier les décalages entre le CLAUDE.md et l'état réel du projet.",
      "2. Présente les décalages trouvés avec des explications claires.",
      "3. Si des décalages existent, suggère s'il faut régénérer ou corriger manuellement le CLAUDE.md.",
    ],
  },
};
