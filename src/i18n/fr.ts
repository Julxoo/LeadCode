import type { Messages } from "./types.js";

export const fr: Messages = {
  templates: {
    header: {
      title: "{name} — Règles du Projet",
      meta1: "Généré automatiquement par [LeadCode](https://github.com/Julxoo/LeadCode) avec la documentation de [Context7](https://context7.com). Ce fichier est la source de vérité pour Claude Code.",
      meta2: "Modifiez selon vos besoins, puis committez dans le contrôle de version.",
    },
    sections: {
      architectureOverview: "Vue d'ensemble de l'architecture",
      stack: "Stack technique",
      projectStructure: "Structure du projet",
      availableScripts: "Scripts disponibles",
      fileNaming: "Conventions de nommage",
      importOrdering: "Ordre des imports",
      projectDecisions: "Décisions du projet",
      existingPatterns: "Patterns existants",
      claudeInstructions: "Instructions pour Claude Code",
    },
    architecture: {
      frontendBackend: "Frontend + Backend",
      fullStackReact: "framework React full-stack",
      frontend: "Frontend",
      reactSpaVite: "SPA React avec Vite",
      framework: "Framework",
      dataLayer: "Couche données",
      database: "Base de données",
      authentication: "Authentification",
      api: "API",
      clientState: "État client",
      i18n: "i18n",
      payments: "Paiements",
      realtime: "Temps réel",
      email: "Email",
      content: "Contenu",
      backgroundJobs: "Tâches de fond",
      fileUpload: "Upload de fichiers",
      projectSize: "Taille du projet",
      sizeSmall: "Petit",
      sizeMedium: "Moyen",
      sizeLarge: "Grand",
      sizeVeryLarge: "Très grand",
      sourceFiles: "fichiers source",
    },
    stackLabels: {
      framework: "Framework",
      orm: "ORM",
      database: "Base de données",
      auth: "Auth",
      validation: "Validation",
      css: "CSS",
      uiComponents: "Composants UI",
      testing: "Tests",
      stateManagement: "Gestion d'état",
      dataFetching: "Data Fetching",
      formLibrary: "Formulaires",
      apiStyle: "Style d'API",
      i18n: "i18n",
      payments: "Paiements",
      email: "Email",
      realtime: "Temps réel",
      cms: "CMS/Contenu",
      fileUpload: "Upload de fichiers",
      jobs: "Jobs/Queue",
      monorepo: "Monorepo",
      deployment: "Déploiement",
      linter: "Linter",
      formatter: "Formatter",
      runtime: "Runtime",
    },
    structure: {
      srcDir: "Code source dans `src/`",
      appRouter: "App Router : `app/`",
      pagesRouter: "Pages Router : `pages/`",
      apiRoutes: "Routes API présentes",
      middleware: "Middleware configuré",
      components: "Composants : `components/`",
      sharedUtils: "Utilitaires partagés : `lib/`",
      services: "Services : `services/`",
      customHooks: "Hooks personnalisés : `hooks/`",
      stateStores: "Stores d'état : `store/`",
      validationSchemas: "Schémas de validation : `schemas/`",
      typeDefinitions: "Définitions de types : `types/`",
      configuration: "Configuration : `config/`",
      reactProviders: "Providers React : `providers/`",
      prismaSchema: "Schéma Prisma : `prisma/schema.prisma`",
    },
    naming: {
      files: "**Fichiers** : kebab-case (ex : `user-profile.ts`, `auth-utils.ts`)",
      reactComponents: "**Composants React** : PascalCase correspondant au nom du composant (ex : `UserProfile.tsx` exporte `UserProfile`)",
      hooks: "**Hooks** : camelCase préfixé par `use` (ex : `useAuth.ts`)",
      constants: "**Constantes/config** : SCREAMING_SNAKE_CASE pour les valeurs, kebab-case pour les fichiers",
      newFilesSrc: "**Nouveaux fichiers** : Placer dans `src/` en suivant la structure existante",
    },
    importOrder: [
      "1. Builtins Node.js (node:fs, node:path)",
      "2. Packages externes (react, next, etc.)",
      "3. Alias internes (@/ ou ~/)",
      "4. Imports relatifs (../ et ./)",
      "5. Imports de types (import type { ... })",
    ],
    instructions: {
      followAll: "Suivre TOUTES les règles de ce document sans exception.",
      respectStructure: "Lors de la création de fichiers, respecter la structure existante et les conventions de nommage.",
      checkPrecedent: "En cas de doute sur un pattern, vérifier le code existant avant d'inventer de nouveaux patterns.",
      neverNewDeps: "Ne jamais introduire de nouvelles dépendances sans demande explicite.",
      smallChanges: "Préférer les changements petits et ciblés aux gros refactorings.",
      serverComponents: "Utiliser les Server Components par défaut. N'ajouter 'use client' que si le composant a besoin d'interactivité.",
      appRouterPages: "Placer les nouvelles pages dans app/ en suivant la structure de routes existante.",
      serverActions: "Utiliser les Server Actions pour les mutations, les Route Handlers pour les endpoints API.",
      prismaAfterChange: "Après modification de schema.prisma, toujours exécuter `npx prisma migrate dev` et `npx prisma generate`.",
      drizzleAfterChange: "Après modification des schémas Drizzle, exécuter `npx drizzle-kit generate` pour créer les migrations.",
      zodValidate: "Valider toutes les entrées aux frontières API avec Zod. Parser, ne pas valider.",
      tailwindClasses: "Utiliser les classes utilitaires Tailwind pour le style. Utiliser cn() pour les classes conditionnelles.",
      shadcnComponents: "Utiliser les composants shadcn/ui de components/ui/ comme briques de base.",
      runTests: "Lancer les tests avec {testing} avant de considérer le travail comme terminé.",
      runLinter: "Lancer {linter} avant de commiter. Corriger tous les warnings.",
      i18nStrings: "Toutes les chaînes visibles par l'utilisateur doivent passer par le système i18n. Ne jamais coder en dur.",
    },
    patterns: {
      clientServerRatio: "**Ratio Client/Serveur** : {clientCount} composants client sur {totalCount} total ({clientPercent}% client)",
      serverActions: "**Server Actions** : {count} fichiers avec 'use server'",
      pathAliases: "**Alias de chemins** : Le projet utilise les imports @/ ou ~/ — continuer à les utiliser",
      barrelFiles: "**Fichiers barrel** : Le projet utilise des re-exports index.ts — suivre ce pattern",
      largeFiles: "**Gros fichiers** (>300 lignes) : {count} fichier(s) — envisager de découper",
      consoleLogs: "**Console.log** : {count} occurrences trouvées — nettoyer avant la production",
    },
  },
};
