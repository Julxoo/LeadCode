import type { Messages } from "./types.js";

export const en: Messages = {
  templates: {
    header: {
      title: "{name} — Project Rules",
      meta1: "Auto-generated by [LeadCode](https://github.com/Julxoo/LeadCode). This file is the source of truth for Claude Code.",
      meta2: "Modify as needed, then commit to version control.",
    },
    sections: {
      architectureOverview: "Architecture Overview",
      stack: "Stack",
      projectStructure: "Project Structure",
      availableScripts: "Available Scripts",
      fileNaming: "File & Naming Conventions",
      importOrdering: "Import Ordering",
      conventions: "Conventions (MUST follow)",
      crossStackRules: "Cross-Stack Rules (CRITICAL)",
      interdictions: "Interdictions (NEVER do)",
      projectDecisions: "Project Decisions",
      existingPatterns: "Existing Code Patterns",
      claudeInstructions: "Claude Code Instructions",
    },
    architecture: {
      frontendBackend: "Frontend + Backend",
      fullStackReact: "full-stack React framework",
      frontend: "Frontend",
      reactSpaVite: "React SPA with Vite",
      framework: "Framework",
      dataLayer: "Data Layer",
      database: "Database",
      authentication: "Authentication",
      api: "API",
      clientState: "Client State",
      i18n: "i18n",
      payments: "Payments",
      realtime: "Realtime",
      email: "Email",
      content: "Content",
      backgroundJobs: "Background Jobs",
      fileUpload: "File Upload",
      projectSize: "Project Size",
      sizeSmall: "Small",
      sizeMedium: "Medium",
      sizeLarge: "Large",
      sizeVeryLarge: "Very large",
      sourceFiles: "source files",
    },
    stackLabels: {
      framework: "Framework",
      orm: "ORM",
      database: "Database",
      auth: "Auth",
      validation: "Validation",
      css: "CSS",
      uiComponents: "UI Components",
      testing: "Testing",
      stateManagement: "State Management",
      apiStyle: "API Style",
      i18n: "i18n",
      payments: "Payments",
      email: "Email",
      realtime: "Realtime",
      cms: "CMS/Content",
      fileUpload: "File Upload",
      jobs: "Jobs/Queue",
      monorepo: "Monorepo",
      deployment: "Deployment",
      linter: "Linter",
      formatter: "Formatter",
      runtime: "Runtime",
    },
    structure: {
      srcDir: "Source code in `src/`",
      appRouter: "App Router: `app/`",
      pagesRouter: "Pages Router: `pages/`",
      apiRoutes: "API routes present",
      middleware: "Middleware configured",
      components: "Components: `components/`",
      sharedUtils: "Shared utilities: `lib/`",
      services: "Services: `services/`",
      customHooks: "Custom hooks: `hooks/`",
      stateStores: "State stores: `store/`",
      validationSchemas: "Validation schemas: `schemas/`",
      typeDefinitions: "Type definitions: `types/`",
      configuration: "Configuration: `config/`",
      reactProviders: "React providers: `providers/`",
      prismaSchema: "Prisma schema: `prisma/schema.prisma`",
    },
    naming: {
      files: "**Files**: kebab-case (e.g., `user-profile.ts`, `auth-utils.ts`)",
      reactComponents: "**React components**: PascalCase filename matching component name (e.g., `UserProfile.tsx` exports `UserProfile`)",
      hooks: "**Hooks**: camelCase prefixed with `use` (e.g., `useAuth.ts`)",
      constants: "**Constants/config**: SCREAMING_SNAKE_CASE for values, kebab-case for files",
      newFilesSrc: "**New files**: Place in `src/` following the existing directory structure",
    },
    importOrder: [
      "1. Node.js builtins (node:fs, node:path)",
      "2. External packages (react, next, etc.)",
      "3. Internal aliases (@/ or ~/)",
      "4. Relative imports (../ and ./)",
      "5. Type imports (import type { ... })",
    ],
    instructions: {
      followAll: "Follow ALL rules in this document without exception.",
      respectStructure: "When creating new files, respect the existing project structure and naming conventions.",
      checkPrecedent: "When unsure about a pattern, check existing code for precedent before inventing new patterns.",
      neverNewDeps: "Never introduce new dependencies without being explicitly asked.",
      smallChanges: "Prefer small, focused changes over large refactors.",
      serverComponents: "Default to Server Components. Only add 'use client' when the component needs interactivity.",
      appRouterPages: "Place new pages in app/ following the existing route structure.",
      serverActions: "Use Server Actions for mutations, Route Handlers for API endpoints.",
      prismaAfterChange: "After changing schema.prisma, always run `npx prisma migrate dev` and `npx prisma generate`.",
      drizzleAfterChange: "After changing Drizzle schemas, run `npx drizzle-kit generate` to create migrations.",
      zodValidate: "Validate all inputs at API boundaries with Zod. Parse, don't validate.",
      tailwindClasses: "Use Tailwind utility classes for styling. Use cn() for conditional classes.",
      shadcnComponents: "Use shadcn/ui components from components/ui/ as building blocks.",
      runTests: "Run tests with the project's {testing} setup before marking work as done.",
      runLinter: "Run {linter} before committing. Fix all warnings.",
      i18nStrings: "All user-facing strings must go through the i18n system. Never hardcode text.",
    },
    patterns: {
      clientServerRatio: "**Client/Server ratio**: {clientCount} client components out of {totalCount} total ({clientPercent}% client)",
      serverActions: "**Server Actions**: {count} files with 'use server'",
      pathAliases: "**Path aliases**: Project uses @/ or ~/ imports — keep using them",
      barrelFiles: "**Barrel files**: Project uses index.ts re-exports — follow this pattern",
      largeFiles: "**Large files** (>300 lines): {count} file(s) — consider splitting",
      consoleLogs: "**Console.log**: {count} occurrences found — clean up before production",
    },
  },

  suggestions: {
    testing: {
      topic: "Testing Strategy",
      simple: {
        description: "Add Vitest for unit tests only",
        pros: ["Fast setup", "Lightweight", "Great DX"],
        cons: ["No E2E coverage"],
        claudeImpact: "Claude will generate unit tests alongside new functions when asked.",
      },
      clean: {
        description: "Vitest + Testing Library for component tests",
        pros: ["Unit + component coverage", "Tests user behavior"],
        cons: ["More setup", "Slower component tests"],
        claudeImpact: "Claude will generate both unit and component tests with proper render/assert patterns.",
      },
      scalable: {
        description: "Vitest + Testing Library + Playwright for E2E",
        pros: ["Full coverage pyramid", "Catches integration bugs"],
        cons: ["Significant setup", "Slower CI"],
        claudeImpact: "Claude will generate tests at all levels and respect the testing pyramid.",
      },
    },
    inputValidation: {
      topic: "Input Validation",
      simple: {
        description: "Add Zod for manual validation in API routes",
        pros: ["Minimal", "TypeScript-native"],
        cons: ["Must remember to validate each route"],
        claudeImpact: "Claude will add z.object().parse() in API routes when reminded.",
      },
      clean: {
        description: "Zod with shared schemas directory and middleware",
        pros: ["DRY schemas", "Consistent validation"],
        cons: ["More structure upfront"],
        claudeImpact: "Claude will import shared schemas and validate automatically in every route.",
      },
    },
    errorHandling: {
      topic: "Error Handling",
      simple: {
        description: "Add error.tsx in each route segment",
        pros: ["Quick", "Follows Next.js conventions"],
        cons: ["No structured error logging"],
        claudeImpact: "Claude will create error.tsx files and handle errors gracefully.",
      },
      clean: {
        description: "Error boundaries + centralized error utilities + structured logging",
        pros: ["Consistent error format", "Debuggable"],
        cons: ["More setup"],
        claudeImpact: "Claude will use the error utilities consistently and produce debuggable error responses.",
      },
    },
    schemaOrg: {
      topic: "Schema Organization",
      simple: {
        description: "Co-locate schemas next to their API routes",
        pros: ["Easy to find", "No indirection"],
        cons: ["Schemas get duplicated across routes"],
        claudeImpact: "Claude will duplicate schemas when the same data is used in multiple routes.",
      },
      clean: {
        description: "Shared /lib/schemas/ directory",
        pros: ["Single source of truth", "DRY"],
        cons: ["One more directory to manage"],
        claudeImpact: "Claude will find and reuse schemas consistently across routes and forms.",
      },
    },
    componentStructure: {
      topic: "Component Organization",
      simple: {
        description: "Flat /components directory",
        pros: ["Simple", "Works for small projects"],
        cons: ["Gets messy at scale"],
        claudeImpact: "Claude will place all components in one directory.",
      },
      clean: {
        description: "Feature-based organization: /components/ui/ + /components/[feature]/",
        pros: ["Scales well", "Clear ownership"],
        cons: ["More directories"],
        claudeImpact: "Claude will organize components by feature and reuse UI primitives.",
      },
    },
    authMiddleware: {
      topic: "Route Protection",
      simple: {
        description: "Check auth in each Server Component/route handler",
        pros: ["Explicit", "Easy to understand"],
        cons: ["Easy to forget on new routes"],
        claudeImpact: "Claude may forget auth checks on new routes unless reminded.",
      },
      clean: {
        description: "middleware.ts with route matcher + per-route checks as backup",
        pros: ["Centralized", "Defense in depth"],
        cons: ["Middleware can be tricky to debug"],
        claudeImpact: "Claude will add routes to the protected matcher and still add server-side checks.",
      },
    },
    loadingStates: {
      topic: "Loading States",
      simple: {
        description: "Add a single loading.tsx at the root app/ level",
        pros: ["Quick", "Covers all routes"],
        cons: ["Same loading UI everywhere"],
        claudeImpact: "Claude will see the pattern and create loading.tsx for new route segments.",
      },
      clean: {
        description: "Per-segment loading.tsx with skeleton UIs matching each page layout",
        pros: ["Better UX", "Layout-aware skeletons"],
        cons: ["More files to maintain"],
        claudeImpact: "Claude will create matching skeleton UIs for each new route segment.",
      },
    },
    metadata: {
      topic: "SEO & Metadata",
      simple: {
        description: "Static metadata export in each page.tsx",
        pros: ["Simple", "Covers basic SEO"],
        cons: ["No dynamic metadata for dynamic routes"],
        claudeImpact: "Claude will add export const metadata to new pages.",
      },
      clean: {
        description: "generateMetadata for dynamic pages + static metadata for others",
        pros: ["Dynamic title/description per route", "Full SEO control"],
        cons: ["More boilerplate per page"],
        claudeImpact: "Claude will generate proper generateMetadata functions with dynamic data.",
      },
    },
    prismaClient: {
      topic: "Prisma Client Singleton",
      simple: {
        description: "globalThis pattern in lib/prisma.ts",
        pros: ["Standard approach", "Prevents hot-reload leaks"],
        cons: ["Requires discipline to always import from there"],
        claudeImpact: "Claude will import from lib/prisma.ts consistently.",
      },
    },
    authSession: {
      topic: "Auth Utility",
      simple: {
        description: "Create lib/auth.ts with getCurrentUser() function",
        pros: ["Centralized", "Easy to use"],
        cons: ["Must remember to use it"],
        claudeImpact: "Claude will call getCurrentUser() in Server Components and Route Handlers.",
      },
      clean: {
        description: "lib/auth.ts with getCurrentUser() + requireAuth() that throws on no session",
        pros: ["Fail-safe", "Clear intent"],
        cons: ["Slightly more code"],
        claudeImpact: "Claude will use requireAuth() at the top of protected routes automatically.",
      },
    },
    envValidation: {
      topic: "Environment Variable Validation",
      simple: {
        description: "Manual Zod validation in env.ts",
        pros: ["No extra deps", "Full control"],
        cons: ["Manual maintenance"],
        claudeImpact: "Claude will import env vars from env.ts and never use process.env directly.",
      },
      clean: {
        description: "Use @t3-oss/env-nextjs for type-safe env with client/server separation",
        pros: ["Type-safe", "Client/server boundary enforcement"],
        cons: ["Extra dependency"],
        claudeImpact: "Claude will import from env.mjs and respect client/server env boundaries.",
      },
    },
    typesDir: {
      topic: "Shared Types Organization",
      simple: {
        description: "Create a types/ directory with domain-specific type files",
        pros: ["Clear location for shared types"],
        cons: ["One more directory"],
        claudeImpact: "Claude will place shared types in types/ and import from there.",
      },
    },
    storeOrg: {
      topic: "Store Organization",
      simple: {
        description: "Create a store/ directory with one file per store",
        pros: ["Simple", "Easy to find"],
        cons: ["Flat structure"],
        claudeImpact: "Claude will create stores in store/ with clear naming.",
      },
    },
    drizzleSchema: {
      topic: "Drizzle Schema Organization",
      simple: {
        description: "All schemas in db/schema.ts",
        pros: ["Simple for small projects"],
        cons: ["Gets large fast"],
        claudeImpact: "Claude will add new tables to the single schema file.",
      },
      clean: {
        description: "db/schema/ directory with one file per domain entity + index.ts barrel",
        pros: ["Scales well", "Easy to find"],
        cons: ["More files"],
        claudeImpact: "Claude will create new schema files per entity and export from index.ts.",
      },
    },
    genericFix: "Address: {message}",
    genericPros: ["Fixes the gap"],
    genericCons: ["May need further refinement"],
    genericClaudeImpact: "Claude will follow the convention once documented in CLAUDE.md.",
  },

  validation: {
    noClaudeMd: "No CLAUDE.md found at {path}. Use generate-claude-md first.",
    frameworkVersionOutdated: "Framework version {version} not found in CLAUDE.md. Version may have been updated.",
    techMissing: "{label}: {value} is in the project but not mentioned in CLAUDE.md.",
    conventionMissing: 'Convention "{description}" is applicable but not in CLAUDE.md.',
    crossStackMissing: "Cross-stack rule for {combo} is applicable but not in CLAUDE.md.",
    gapStillExists: "High-severity gap still exists: {message}",
    inSync: "CLAUDE.md is in sync with the project.",
    driftsFound: "Found {count} drift(s). Consider running generate-claude-md to update.",
  },

  tools: {
    generateSuccess: "CLAUDE.md generated successfully",
    updateSuccess: "CLAUDE.md updated successfully",
    dirNotFound: "Project directory not found: {path}",
  },

  prompts: {
    setupTitle: "Full LeadCode workflow: analyze repo → detect gaps → suggest conventions → generate CLAUDE.md",
    setupSteps: [
      "1. Call analyze-repo to scan the project and get a full technical analysis.",
      "2. Call detect-gaps with the analysis to identify structural gaps.",
      "3. Call suggest-conventions with the analysis and gaps to get improvement options.",
      "4. Present the analysis, gaps, and suggestions to me in a clear summary.",
      "5. Ask me which options I prefer for each gap (simple / clean / scalable).",
      "6. Once I've chosen, call generate-claude-md with my choices to create the CLAUDE.md file.",
      "",
      "Be thorough and explain each gap and suggestion clearly.",
    ],
    validateTitle: "Check if an existing CLAUDE.md is still in sync with the project",
    validateSteps: [
      "1. Call validate-claude-md to check for drifts between the CLAUDE.md and actual project state.",
      "2. Present any drifts found with clear explanations.",
      "3. If drifts are found, suggest whether to regenerate or manually fix the CLAUDE.md.",
    ],
  },
};
